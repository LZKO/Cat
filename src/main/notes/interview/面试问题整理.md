# 面试问题整理



[TOC]



### Redis

------

#### 应用场景

1.缓存

2.共享Session

3.消息队列系统

4.分布式锁



#### 单线程的Redis为什么快

1.纯内存操作

2.单线程操作，避免了频繁的上下文切换

3.合理高效的数据结构

4.采用了非阻塞的I/O多路复用机制



#### Redis的数据结构及使用场景

1.String字符串：字符串类型是Redis最基础的数据结构，首先键都是字符串类型，且其他几种数据结构都是在字符串类型基础上构建的，我们常使用的set key value命令就是字符串（语句没读懂？）。常用在缓存、技术、共享Session、限速等。

2.Hash哈希：在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可用来存放用户信息，如实现购物车（如何实现？）。

3.List列表（双向链表）：列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。

4.Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，且集合中的元素是无序的，不能通过索引下标获取元素。利用Set的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

5.Sorted Set有序集合（跳表实现）：Sorted Set多了一个权重参数Score，集合中的元素能够按Score进行排列。可以做排行榜应用，取TOP N操作。

| 数据类型 | 可以存储的值           | 操作                                                         |
| -------- | ---------------------- | ------------------------------------------------------------ |
| STRING   | 字符串、整数或浮点数   | 对整个字符串或字符串的其中一部分执行操作；对整数和浮点数执行自增或自减操作 |
| LIST     | 列表                   | 从两端压入或者弹出元素；对单个或者多个元素进行修剪，只保留一个范围内的元素 |
| SET      | 无序集合               | 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集从集合里面随机获取元素 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对；获取所有键值对；检查某个键是否存在 |
| ZSET     | 有序集合               | 添加、获取、删除元素；根据分支范围或者成员来获取元素；计算一个键的排名 |
|          | ··                     |                                                              |

#### Redis的数据过期策略

Redis中数据过期策略采用定期删除+惰性删除策略

- 定期删除策略：Redis启用一个定时器定时监视所有的key，判断key是否过期，过期的话就删除。这种策略可以保证过期的key最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗CPU资源，并且当key已过期，但是定时器还处于未唤起状态，这段时间内key仍然可以用。

- 惰性删除策略：在获取key是时，先判断key是否过期，如果过期则删除。缺点：如果这个key一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。

- 这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不再是每次扫描全部的key了，而是随机抽取一部分key进行检查，这样就降低了对CPU资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求（语句不太通顺？）。但有时候比较巧，既没有被定时器抽取到，又没有被使用，只写数据如何从内存中消失？此时我们有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。淘汰策略分为：

  ​	当内存不足以容纳新写入数据时，

  - 新写入操作会报错（Redis默认策略）

  - 在键空间中，移除最近最少使用的Key。（LRU推荐使用）

  - 在键空间中，随机移除某个Key。

  - 在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis即当缓存，又做持久化存储时才用。

  - 在设置了过期时间的键空间中，随机移除某个Key。

  - #### 在设置了过期时间的键空间中，有更早过期时间的Key优先移除



#### Redis的LRU具体实现：

传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致select *的时候产生大量非热点数据占领头部数据（没看懂），故需要改进。Redis每次按key获取一个值的时候，都会更新value的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的。在3.0的时候，改进了算法，首先第一次随机选取的key都会放入一个pool中（poll的大小为16），pool中的key是按lru的大小顺序排列的。接下来每次随机选取的key的lru的值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。



#### 如何解决Redis缓存雪崩的问题

1.使用Redis高可用架构：使用Redis集群来保证Redis服务不会挂掉。

2.缓存时间不一致，给缓存的失效时间加上一个随机值，避免集体失效。

3.限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务。



#### 如何解决Redis缓存穿透问题

（TODO 什么是缓存穿透？）

1.在接口做校验

2.存null值（缓存击穿加锁）

3.布隆过滤器拦截：将所有可能的查询key先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，若不存在，则直接返回。布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素存在，可能会被误判，布隆过滤器说某个元素不存在，则一定不存在。



#### Redis的持久化机制

Redis为了保证效率，数据缓存在了内存中，但会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。

Redis的持久化策略有两种：

1. RDB（快照持久化）：加个某个时间点的所有数据都写入到磁盘里面；可以将快照复制到其他服务器从而创建具有相同数据的服务器副本；如果系统发生故障，将会丢失最后一次创建快照之后的数据；若数据量很大，保存快照的时间会很长。当Redis需要做持久化时，Redis会fock一个子进程，子进程将数据写到磁盘上的一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。

2. AOF（只追加文件）：将写命令添加到AOF文件（Append Only File）的末尾。使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定何时同步到磁盘。有以下同步选项：

   | 选项     | 同步频率               |
   | -------- | ---------------------- |
   | always   | 每个写命令都同步       |
   | everysec | 每秒同步一次           |
   | no       | 让操作系统决定何时同步 |

   - always选项会眼中降低服务器的性能；
   - everyse选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，且Redis每秒执行一次同步对服务器性能几乎没有任何影响；
   - no选项并不能给服务器性能带来多大提升，且会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF文件会越来越大。Redis提供了一只能怪将AOF重写的特性，能够去除AOF文件中冗余写命令。

这两种持久化方法既可以同时使用，又可以单独使用，在某些情况下甚至可以都不使用，具体选择哪种持久化方法需要根据用户的数据及应用来决定。



#### Redis和memcached的区别

相同点：两者都是菲关系型内存键值数据库；

不同点：

​	1.数据类型：memcached仅支持字符串类型，而Redis支持五种不同的数据类型，可以更灵活的解决问题。

​	2.数据持久化：Redis支持两种持久化策略，RDS快照和AOF日志，而Memcached不支持持久化。

​	3.分布式：Memcached不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点；Redis Cluster实现了分布式的支持。

​	4.内存管理机制：在Redis中，并不是所有数据都一直存储在内存中的，可以将一些很久没用的value交换到磁盘，而Memcached的数据则会一直在内存中；Memcached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但这种方式使得内存的利用率不高，如块的大小为128bytes，只存储100bytes的数据，剩下的28bytes就浪费掉了。



#### Redis并发竞争key的解决方案

（TODO看不懂）

1.分布式锁+时间戳

2.利用消息队列



#### Redis与MySQL双写一致性方案

先更新数据库，再删除缓存。数据库的读操作，要远快于写操作，所以脏数据很难出现。可以对异步延时删除策略，保证读请求完成以后，再进行删除操作。（TODO没看懂）



#### Redis的管道pipeline

对于单线程阻塞式的Redis，pipeline可以满足批量的操作，把多个命令连续的发送给Redis Server，然后一一解析响应结果。Pipelining可以提高批量处理性能，提升原因主要是TCP连接中减少了“交互往返”的时间。pipeline底层是通过把所有的操作封装成流，redis有定义自己的出入输出流（TODO不通顺？）。在sync()方法执行操作，每次请求放在队列里面，解析响应包。



#### Redis的底层数据结构

（TODO不太理解，同时需要完善）

1.字典：

dictht是一个散列表结构，使用拉链法解决哈希冲突。

```
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```

```
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

Redis的字典dict中包含两个哈希表dictht，这是为了方便进行rehash操作。在扩容时，将其中一个dictht上的键值对rehash到另一个dictht上面，完成之后释放空间并交换两个dictht的角色。

```
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;
```

rehash操作不熟一次性完成的，而是采用渐进放手，这是为了避免一次性执行过多的rehash操作给服务器带来过大的负担。

渐进式rehash通过记录dict的rehashidx完成，他从0开始，然后每执行一次rehash都会递增。如在一次rehash中，要把dict[0] rehash到dict[1]。这一次会把dict[0]上的table[rehashidx]的键值对rehash到dct[1]上，dict[0]的table[rehashidx]指向null，并领rehashidx++。

在rehash期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式rehash。

采用渐进式rehas会导致字典中的数据分散在两个dictht上，因此对字典的查找操作也需要到对应的dictht去执行。

```
/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d)) return 0;

    while (n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d->ht[0].size > (unsigned long) d->rehashidx);
        while (d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d->ht[0].table[d->rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while (de) {
            uint64_t h;

            nextde = de->next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;
            d->ht[0].used--;
            d->ht[1].used++;
            de = nextde;
        }
        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    /* Check if we already rehashed the whole table... */
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}
```

2、跳跃表

是有序集合的地城实现之一。

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

（TODO缺少图片）

在查找时，从上层指针开始查找，找到对应的区间后再到下一层去查找。如图所示（TODO 图挂掉了）

与红黑树等平衡树相比，跳跃表具有以下优点：

- 插入速度非常快，因为不需要进行旋转灯操作来维护平衡性；
- 易实现；
- 支持无锁操作。



#### 使用场景

##### 1、计数器

可以对String进行自增自减操作，实现计数器功能。

Redis这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

##### 2、缓存

将热点数据放在内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

##### 3、查找表

如DNS记录就很适合使用Redis进行存错。

查找表和缓存类似，也是利用Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

##### 4、消息队列

List是一个双向链表，可以通过lpush和rpop写入和读取消息。

不过最好使用RocketMQ等消息中间件。

##### 5、会话缓存

可以使用Redis统一存储多态应用服务器的会话信息。

当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以氢气任意一个应用服务器，从而更容易实现高可用性及可伸缩性。

##### 6、分布式锁实现

在分布式场景下，无法使用单机环境下的锁来对多个节点的进程进行同步。

可以使用Redis自带的SETNX命令来实现分布式锁，除此之外，还可以使用官方提供的RedLock分布式锁实现。

##### 7、其他

Set可以实现交集、并集等操作，从而实现共同好友等功能。

ZSet可以实现有序性操作，从而实现排行榜等功能。



#### 事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis最简单的事务实现方式是使用MULTI和EXEC命令将事务操作包围起来。





### MySQL

------

#### 事务的基本要素

事务指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。

1.原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全部不执行。

​	回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改即可。

2.一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

3.隔离性（Isolation）：一个事务所做的修改在最终提交前，对其他事务是不可见的。

4.持久性：事务提交后，其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

事务的ACID特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能满足。此时只要能满足原子性，就一定能满足一致性。
- 在无并发的情况下，多个事务并行执行，事务不仅要满足满足原子性还要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

#### 事务的并发问题

0.丢失修改：T1和T2两个事务都对一个数据修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。

1.脏读：事务A读取事务B更新的数据，然后B回滚操作，则A读取到的数据是脏数据。

2.不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

3.幻读：A事务读取了B事务已经提交的新增数据。注意和不可重复读的区别，这是是新增，不可重复是更改（或删除）。select某记录是否存在，不存在，准备插入此记录，但执行insert时发现此记录已存在，无法插入，此时就发生了幻读。



#### MySQL事务隔离级别

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| 读未提交     | 是   | 是         | 是   |
| 不可重复读   | 否   | 是         | 是   |
| 可重复读     | 否   | 否         | 是   |
| 串行化       | 否   | 否         | 否   |

在MySQL可重复的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决是不彻底的。通过索引枷锁，间隙锁，next  key lock可以解决幻读的问题。



#### MySQL的逻辑结构

- 最上层的服务类似其他CS结构，比如连接处理，授权处理。
- 第二层是MySQL的服务层，包括SQL的解析分析优化，存储过程触发器视图等也在这一层实现。
- 最后一层是存储引擎等实现，类似于Java接口的实现，MySQL的执行器在执行SQL的时候只会关注API的调用，完全屏蔽了不同引擎实现间的差异。如Select语句，先会判断当前用户是否拥有全新，其次到缓存（内存）查询是否有响应的结果集，如果没有，再执行解析SQL，优化生成执行计划，调用API执行。



#### SQL执行顺序

SQL的执行顺序：from---where---group by --- having---select --- order by



#### MVCC,redolog,undolog,binlog

- undolog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现，是逻辑日志...（TODO 略过，后面再补，参考：https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md）。
- redoLog 是重做日志文件是记录数据修改之后的值（TODO语句不通顺？）用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲（redo log buffer），概不负责日志是易失性的；二是磁盘上的重做日志文件（redo log file），该部分是持久的。...（TODO 略过，后面再补，参考：https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md）。
- MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行的事务ID，指向该行（undolog表中）回滚段的指针。...（TODO 略过，后面再补，参考：https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md）。
- binlog由MySQL的Server层实现，是逻辑日志，记录的是SQL语句的原始逻辑。...（TODO 略过，后面再补，参考：https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md）。



#### binlog和redolog的区别

1.redolog是在InnoDB存储引擎层产生的，而binlog是MySQL数据库的上层服务层产生的。（TODO不够细致）

2.两种日志记录的内容形式不同。MySQL的binlog是逻辑日志文件，其记录是对应的SQL语句。而innodb存储引擎层面的重做日志是物理日志（TODO没读懂）。

...（TODO 略过，后面再补，参考：https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md）。

#### MySql如何保证一致性和持久性

（TODO 略过，后面再补，参考：https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md）。



#### InnoDB的行锁模式

（TODO 略过，后面再补，参考：https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md）。



#### 为什么选择B+树作为索引结构

- Hash索引：底层哈希表，哈希表是一种以key-value形式存储数据的结构，多个数据在存储关系上是完全没有任何顺序关系，故对于区间查询是无法通过索引查询的，需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+树是一种多路平衡查找树，所以他们的节点是天然有序的（左子节点小于父节点，父节点小于右子节点），对于范围查询的时候不需要做全表扫描。

- 二叉查找树：解决了排序的基本问题，但是无法保证平衡，可能退化为链表。

- 平衡二叉树：通过旋转姐姐了平衡的问题，但是旋转操作效率太低。

- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太过，IO次数太多。

- B+树：在B树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针接成链表，范围查询更加高效。与红黑树相比较：

  - 更少的查找的次数：平衡树查找操作的时间复杂度和树高（h）相关，O（h）=O
    $$
    (\log_d{N})
    $$
    其中d为每个节点的出度。

  - 利用磁盘的预读特性：为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，且只需要很短的磁盘旋转时间，速度非常快；操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全，使得一次I/O就能完全载入一个节点，并且可以利用预读特性，相邻节点也能被预先载入。



#### 什么是B+ Tree？

1.数据结构

B Tree指的是Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree是基于B Tree和叶子节点顺序访问指针进行实现的，它具有B Tree的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在B+ Tree中，一个节点中的key从左到右非递减排列，如果某个指针的左右相邻key分别为 keyi 和keyi+1，且不为null，则该指针指向节点的所有key大于等于keyi且小于等于keyi+1。

2.操作

进行查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点进行二分查找，找出key所对应的data。

插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转灯操作来维护平衡性。



#### B+树的叶子节点都可以存哪些东西

可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称为聚簇索引。而索引B+树的叶子节点存储了主键的值是非主键索引，也被称之为非聚簇索引。



#### 覆盖索引

指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。



#### 索引的优点

- 大大减少了服务器需要扫描的数据行数
- 帮助服务器进行排序和分组，以及避免创建临时表（B+ Tree索引是有序的，可以用于ORDER BY 和GROUP BY操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 所及I/O变为顺序I/O（B+ Tree索引是有序的，会将相邻的数据都存储在一起）。



#### 索引的使用条件

- 对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效。
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。



#### 查询在什么时候不走（预期中的）索引

1.模糊查询 %like

2.索引列参与计算，使用了函数

3.非最左前缀顺序

4.where对null判断

5.where不等于

6.or操作有至少一个字段没有索引

7.需要回表的查询结果集过大（超过配置的范围）



#### 数据库优化指南

1.创建并使用正确的索引

2.只返回需要的字段：最好不要使用SELECT *语句。

3.减少交互次数（批量提交）

4.设置合理的Fetch Size（数据每次返回给客户端的条数）

5.使用Explain进行分析：Explain用来分析SELECT语句，开发人员可以通过分析Explain结果来优化查询语句。比较重要的字段有：

- select_type：查询类型，有见地查询、联合查询、子查询等。
- key：使用的索引
- rows：扫描的行数



#### InnoDB和MyISAM

##### 两者比较

- 事务：InnoDB是事务型的，可以使用Commit和Rollback语句。
- 并发：MyISAM只支持表级锁，而InnoDB还支持行级锁。
- 外键：InnoDB支持外键。
- 备份：InnoDB支持在线热备份。
- 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，且恢复速度也更慢。
- 其他特性：MyISAM支持压缩表和空间数据索引。

##### InnoDB

是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其他存储引擎。

实现了四个标准的隔离级别，默认级别是可重复度（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+Next-Key Locking防止幻读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有跟大的提升。

内部做了很多优化，包括从磁盘读取数据时采用可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够枷锁插入查找的插入缓冲区等，

支持真正的在线热备份。其他存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

##### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表枷锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但在表有读取操作的同时，也可以往表中插入新的记录，哲别称为并发插入（CONCURRENT INSERT）。

可以手动或者自动执行检查和修复操作，但和事务恢复及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

若指定了DELAY_KEY_WRITE选项，在每次修改完成时，不会立即将修改的索引数据写入磁盘，而是写到内存中的缓冲区，只有在清理缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时，会造成索引损坏，需要执行修复操作。



### Java基础

------

#### 数据类型

##### 1.基本数据类型

- byte/8
- char/16
- short/16
- int/32
- float/32
- long/64
- double/64
- boolean/~

boolean只有两个值：true、false，可以使用1 bit来存储，但是具体大小没有明确规定。JVM会在编译时期将boolean类型数据转换为int，使用1来表示true，使用0来表示false。JVM支持boolean数组，是通过读写byte数组来实现的。

##### 2.包装类型

基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。

```java
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
```

##### 3.缓存池

new Integer(123)与Integer.valueOf(123)的却别在于：

- new Integer(123)每次都会创建一个新的对象；
- Integer.valueOf(123)会使用缓存池中的对象，多次调用会取得同一个对象的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

valueOf方法实现比较简单，先判断值是否在缓存池中，若在就直接返回缓存池中的内容。

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

在java 8中，Integer缓存池的默认大小为 -128~127。

```java
static final int low = -128;
static final int high;
static final Integer cache[];

static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
}
```

编译器会在自动装箱过程调用valueOf方法，故多个值相同且值在缓存池范围内的Integer实例使用自动装箱来创建，那么就会引用相同的对象。

```java
Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
```

基本类型对应的缓冲池如下：

- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

在使用这些基本类型对应的包装类型时，若该数值在缓冲池范围内，就可以直接使用缓冲池创建的对象。

在jdk1.8所有的数值类缓冲池中，Integer的缓冲池IntegerCache比较特殊，该缓冲池的下界为 -128，上界默认是127，但上界可调，在启动JVM时，通过-XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在JVM初始化时，会设定一个名为java.lang.IntegerCache.high 系统属性，IntegerCache初始化时会读取该系统属性来决定上界。

[StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123](https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123)



#### String

##### 概述

String被声明为final，故它不可被继承。（Integer等包装类也不能被继承）

在java 8中，String内部使用char数组存储数据。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
```

在java 9之后，String使用byte数组存储字符串，同时使用coder来标识使用哪种编码

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
```

value被声明为final，意味着value数组初始化之后就不能再引用其它数组。并且String内部没有改变value数组的方法，因此可以保证String不可变。

##### 不可变的好处

1、可以缓存hash值

因为String的hash值经常被使用，如String用做HashMap的key。不可变的特性使得hash值也不可变使得hash值也不可变，因此只需要进行一次进行计算。

2、String pool的需要

如果一个String对象已经被创建过了，那么就会从String Pool中取得引用。只有String是不可变的，才可能使用String Pool。

3、安全性

String 经常作为参数，String不可变性可以保证参数不可变。

4、线程安全

String不可变性天生具备线程安全，可以在多个线程中安全地使用。

[Program Creek : Why String is immutable in Java?](https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/)

##### String, StringBuffer and StringBuilder

1. 可变性

   String不可变，StringBuffer和StringBuider可变

2. 线程安全

   - String不可变，故是线程安全的。
   - StringBuider不是线程安全的
   - StringBuffer是线程安全的，内部使用synchronized同步。

##### String Pool

字符串常量池（String pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。还可以使用String的intern()方法在运行过程将字符串添加到String pool中。

当一个字符串调用intern()方法时，若String pool中已存在一个字符串和该字符串字面量相等(使用equals()方法确定)，就会返回String pool 中字符串的引用。；否则就会在String pool中添加一个新的字符串，并返回这个新字符串的引用。

下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4);           // true
```

若采用"bbb"这种字面量的形式创建字符串，会自动将字符串放入String pool中。

```java
String s5 = "bbb";
String s6 = "bbb";
System.out.println(s5 == s6);  // true
```

在java 7之前，String pool被放在运行时常量池中，它属于永久代。而在java 7之中，String pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError错误。

- [StackOverflow : What is String interning?](https://stackoverflow.com/questions/10578984/what-is-string-interning)
- [深入解析 String#intern](https://tech.meituan.com/in_depth_understanding_string_intern.html)

##### new String("abc")

使用这一方式会创建两个对象（前提是String pool中没有"abc"字符串对象）。

- "abc"属于字符串字面量，所以在编译时期会在String pool中创建一个字符串对象，指向这个"abc"字符串字面量；
- 使用new方式会在堆中创建一个字符串对象。

#### 关键字

##### final

1.数据

声明数据为常量，可以是编译时常量，也可以是运行时被初始化后不能改变的常量。

- 对于基本类型，final使数值不变；
- 对于引用类型，final使引用不变，也就不能引用其它对象，但被引用对象本身是可以修改的。

```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

2.方法

声明的方法不能被子类重写。

private 方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类的方法，而是子类中定义的一个新的方法。

3.类

声明类不允许被继承。

##### static

1.静态变量

- 静态变量：又称为类变量，即这个变量属于这个类，这个类的所有实例共享该变量，可以通过类名直接访问。静态变量在内存中只存在一份。
- 实例变量：每创建一个实例就会产生一个变量，它与该实例同生共死。

```java
public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
```

2.静态方法

静态方法在类加载的时候就存在了，它不依赖任何实例。故静态方法必须有实现，即它不能是抽象方法。

```java
public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
}
```

只能访问所属类的静态字段和静态方法，方法中不能有this和super关键字，因为这两个关键字与具体对象相关联。

```java
public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;     // 'A.this' cannot be referenced from a static context
    }
}
```

3.静态语句块

静态语句块在类初始化时运行一次。

```java
public class A {
    static {
        System.out.println("123");
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
```

4.静态内部类

非静态内部类依赖于外部类的实例，即需要先创建外部类的实例，才能用该实例去创建非静态内部类。而静态内部类不需要。

```java
public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
```

静态内部类不能访问外部类的非静态变量和方法。

5.静态导包

在使用静态变量和方法时不用再指明ClassName，简化代码，但可读性降低。

```java
import static com.xxx.ClassName.*
```

6.初始化顺序

静态变量和静态语句块优先于实例变量和实例语句块，静态变量和静态语句块在代码中初始化的顺序取决于它们在代码中的顺序。

```java
public static String staticField = "静态变量";
```

```java
static {
    System.out.println("静态语句块");
}
```

```java
public String field = "实例变量";
```

```java
{
    System.out.println("普通语句块");
}
```

最后才是构造参数的初始化。

```java
public InitialOrderTest() {
    System.out.println("构造函数");
}
```

存在继承的情况下，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

#### Object通用方法

##### 概览

```java
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
```

##### equals()

1.等价关系

两个对象具有等价关系需要满足五个条件：

- 自反性

  ```java
  x.equals(x); // true
  ```

- 对称性

  ```java
  x.equals(y) == y.equals(x); // true
  ```

- 传递性

  ```java
  if (x.equals(y) && y.equals(z))
      x.equals(z); // true;
  ```

- 一致性

  ```java
  x.equals(y) == x.equals(y); // true
  ```

- 与null比较

  对任何不是null的对象x调用x.equals(null)结果都为false

  ```java
  x.equals(null); // false;
  ```

2.等价与相等

- 对于基本类型，==判断两个值是否相等，基本类型没有equals()方法。
- 对于引用类型，==判断两个变量是否引用同一个对象，equals()判断两个引用的对象是否等价。

```java
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
```

3.实现

- 检查是否为同一个对象的引用，是则直接返回true；
- 检查是否为同一个类型，若不是，直接返回false；
- 将Object对象进行转型；
- 判断每个关键域是否相等。

```java
public class EqualExample {

    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
```

##### hashCode()

hashCode()返回哈希值，equals()用来判断两个对象是否等价。等价两个对象散列值一定相同，但散列值相同的两个对象不一定等价，因为哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。

在覆盖equals()方法时应当总是覆盖hashcode()方法，保证等价的两个对象哈希值也相等。

HashSet和HashMap等集合类使用了hashcode()方法来计算对象应该存储的位置，因此要讲这些对象添加到这些集合类中，需要让对应的类实现hashCode()方法。

下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。

```java
EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet<EqualExample> set = new HashSet<>();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
```

理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。

R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：`31*x == (x<<5)-x`，编译器会自动进行这个优化。

```java
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
```

##### toString()

默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。



##### clone()

1.cloneable

clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。

```java
public class CloneExample {
    private int a;
    private int b;
}
```

```java
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'
```

重写 clone() 得到以下实现：

```java
public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
```

```java
CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
```

```java
java.lang.CloneNotSupportedException: CloneExample
```

以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。

应该注意的是，clone()方法不是Cloneable接口的方法，而是Object的一个protected方法。Cloneable接口只是规定，如果一个类没有实现Cloneable接口又调用了clone()方法，就会抛出 CloneNotSupportedException。

```java
public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

2.浅拷贝

拷贝对象和原始对象的引用类型引用同一个对象。

```java
public class ShallowCloneExample implements Cloneable {

    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
```

```java
ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
```

3.深拷贝

拷贝对象和原始对象的引用类型引用不同对象。

```java
public class DeepCloneExample implements Cloneable {

    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
```

```java
DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
```

4.clone()的替代方案

使用clone()方法拷贝一个对象既复杂又有风险，它会抛出异常，且还需要类型转换。Effective Java书上讲到，最好不要去使用clone()方法，可以使用拷贝构造函数或拷贝工厂来拷贝一个对象。

```java
public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i < original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
```

```java
CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
```

#### 继承

##### 访问权限

java中有三个访问权限修饰符：private、protected及public，若不加修饰符表示包级可见。

可以对类和类中的成员（字段和方法）加上访问修饰符。

- 类可见表示其他类可以用这个类创建实例对象。
- 成员可见表示其他类可以用这个类的实例对象访问到该成员。

protected用于修饰成员，表示在继承体系中成员对于子类可见，这个修饰符对于类没有意义。

设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。

若子类的方法重写了父类的方法，则子类中该方法的访问级别不允许低于父类中该方法的访问级别。这是为了确保使用父类实例的地方都可以使用子类去代替，即满足里氏替换原则。

字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。

```java
public class AccessExample {
    public String id;
}
```

可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。

```java
public class AccessExample {

    private int id;

    public String getId() {
        return id + "";
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
```

但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

```java
public class AccessWithInnerClassExample {

    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问
    }
}
```

##### 抽象类与接口

1.抽象类

抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。

2.接口

接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。

从java 8开始，接口可以拥有默认的方法实现，因为不支持默认方法的接口的维护成本太高。在java 8之前若一个接口想添加新的方法，需要修改所有实现了该接口的类，让他们都实现新增的方法。

接口的成员（字段+方法）默认都是public的，且不允许为privat或protected。

接口的字段默认都是static和final的。

3.比较

- 设计层面上，抽象类提供了一种IS-A关系，需要满足里氏替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种LIKE-A关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具体IS-A关系。
- 从使用上，一个类可以实现多个接口，但不能继承多个抽象类。
- 接口的字段只能是static和final的，抽象类的字段没有此限制。
- 接口的成员只能是public的，抽象类的没有此限制。

4.接口

使用接口：

- 需要让不相关的类都实现一个方法。如不相关的类都可以实现Compareable接口中的compareTo()方法；
- 需要使用多重继承。

使用抽象类：

- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员访问权限，而不是都为public。
- 需要继承非静态和非常量字段。

很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地位一个类添加方法。且从hava 8开始，接口也可以有默认的方法实现，使得修改接口的成本变得很低。

- [Abstract Methods and Classes](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)
- [深入理解 abstract class 和 interface](https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/)
- [When to Use Abstract Class and Interface](https://dzone.com/articles/when-to-use-abstract-class-and-intreface)

5.super

- 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。
- 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

[Using the Keyword super](https://docs.oracle.com/javase/tutorial/java/IandI/super.html)

6.重写与重载

重写：

存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。

为了满足里式替换原则，重写有以下三个限制：

- 子类方法的访问权限必须大于等于父类方法；
- 子类方法的返回类型必须是父类方法返回类型或为其子类型。
- 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。

使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。

下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：

- 子类方法访问权限为 public，大于父类的 protected。
- 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。
- 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。
- 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。

```java
class SuperClass {
    protected List<Integer> func() throws Throwable {
        return new ArrayList<>();
    }
}

class SubClass extends SuperClass {
    @Override
    public ArrayList<Integer> func() throws Exception {
        return new ArrayList<>();
    }
}
```

在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

- this.func(this)
- super.func(this)
- this.func(super)
- super.func(super)

重载(Overload)：

存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。

应该注意的是，返回值不同，其它都相同不算是重载。

#### 异常

Throwable可用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。其中Error表示JVM无法处理的错误，Exception分为两种：

- 受检查异常（Checked Exception）：需要try...catch语句捕获并进行处理，且可以从异常中恢复。
- 非受检查异常（Unchecked Exception）：是程序运行时错误，如除0会引发Arithmetic Exception，此时程序崩溃且无法恢复。

Error`和`Exception的区别：

Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。

受检查异常：

在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。

除了RuntimeException及其子类外其他的Exception及其子类都属于这类异常，当程序中可能出现这类异常，要么使用try-catch语句进行捕获，要么用throws子句抛出，否则编译无法通过。

非受检查异常：

包括RuntimeException及其子类和Error。

`不受检查异常`为编译器不要求强制处理的异常，`检查异常`则是编译器要求必须处置的异常。

#### 集合

##### 概述

容器主要包括Collection和Map两种，Collection存储这对象的集合，Map存储键值对（两个对象）的映射表。

Collection

1.Set

- TreeSet：基于红黑树实现，支持有序性操作。查找效率不如HashSet，HashSet查找的时间复杂度为O(1)，TreeSet为O(logN)。
- HashSet：基于哈希表实现，支持快速查找，不支持有序性操作。且失去了元素的插入顺序信息，即使用Iterator遍历HashSet得到的结果是不确定的。
- LinkedHashSet：具有HashSet的查找效率，且内部使用了双向链表维护元素的插入顺序。

2.List

- ArrayList：基于动态数组实现，支持随机访问。
- Vector：和ArrayList类似，它是线程安全的。
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中插入和删除元素。此外，LinkedList还可以用作栈、队列和双向队列。

3.Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于堆结构实现，可以用它实现优先队列。

Map

- TreeMap：基于红黑树实现。
- HashMap：基于哈希表实现。
- HashTable：和HashMap类似，但它是线程安全的，即多个线程同时写入HashTable不会导致数据不一致。它是遗留类，不应该去使用它，使用ConcurrentHashMap来支持线程安全，ConcurrentHashMap的效率更高，因为它使用分段锁（TODO进一步学习）。
- LinkedHashMap：使用双向链表维护元素顺序，顺序为插入顺序或最近做少使用（LRU）顺序。

##### 源码分析

若没有特别说明，以下源码分析基于JDK1.8。

###### ArrayList：

1.概述

基于数组实现，故支持随机访问。RandomAccess接口标志着该类支持快速随机访问。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

数组默认大小为10。

```java
private static final int DEFAULT_CAPACITY = 10;
```

2.扩容

添加元素时使用ensureCapacityInternal()方法来保证容量足够，若不够，需要使用grow()方法进行扩容，新容量的大小为oldCapacity + (oldCapacity >> 1)，即旧容量的1.5倍。

扩容操作需要调用Arrays.copyOf()，把原数组整个复制到新数组中，该操作代价很高，因此在创建时就指定大概的容量大小，减少扩容次数操作。

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

3.删除元素

需要调用System.arraycopy()将index+1后面的元素都复制到index位置上，该操作时间复杂度为O(N)，可以看出ArrayList删除代价较高。

```java
public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
```

4.序列化

ArrayList基于数组实现，且具有动态扩展性，故保存元素的数组不一定都会被使用，就没必要全部执行序列化。

保存元素的数组elementData使用transient修饰，该关键字声明数组默认不会被序列化。

```java
transient Object[] elementData; // non-private to simplify nested class access
```

ArrayList实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素有元素填充的那部分内容。

```java
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size > 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i<size; i++) {
            a[i] = s.readObject();
        }
    }
}

```

```java
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i<size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
```

序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。

```java
ArrayList list = new ArrayList();
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
oos.writeObject(list);
```

5.Fail-Fast

modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。

在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。

###### Vector

1.同步

它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
```

2.扩容

Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。

```java
public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}
```

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。

```java
public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector() {
    this(10);
}
```

3.与ArrayList比较

- Vector是同步的，开销比ArrayList大，访问速度更慢。最好用ArrayList而不是Vector，因为同步操作可以由程序员自己来控制。
- Vector每次请求扩容为其大小的2倍（也可以通过构造函数设置其增长的容量），而ArrayList是1.5倍。

4.替代方案

可以使用Collections.synchronizedList() 得到一个线程安全的ArrayList。

```java
List<String> list = new ArrayList<>();
List<String> synList = Collections.synchronizedList(list);
```

也可以使用concurrent并发包下的CopyOnWriteArrayList类。

```java
List<String> list = new CopyOnWriteArrayList<>();
```

###### CopyOnWriteArrayList

1.读写分离

写操作在一个复制的数组上进行，读操作在原数组中进行，读写分离，互不影响。

写操作需要加锁，防止并发写入时导致写入数据丢失。

写操作之后需要把原始数组指向新的复制数组。

2.使用场景

在写操作时允许读，提高了读操作的性能，适合读多写少的场景。

缺陷：

- 内存占用：在写操作时需要复制一个新的数组，内存使用是原来的两倍。
- 数据不一致：读操作不能读取实时性的数据，因为部分写操作还未同步到读数组中。

故，不适合内存敏感及对数据实时性眼球高的场景。

###### LinkedList

1.概览

基于双向链表实现，使用Node存储链表节点信息。

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
}
```

每个链表存储了first和last指针：

```java
transient Node<E> first;
transient Node<E> last;
```

2.与ArrayList比较

ArrayList基于动态数组实现，LinkedList基于双向链表实现。ArrayList和LinkedList的区别可以归结于数组和链表的区别：

- 数组支持随机访问，但插入删除的代价很高，需要移动大量元素；
- 链表不支持随机访问，但插入删除只需要改变指针。

###### HashMap

为了便于理解，一下源码分析基于JDK 1.7为主。

1.存储结构

Entry类型的数组table。Entry存储着键值对。它包含了四个字段，从next字段可以看出Entry是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap使用拉链法解决冲突，同一个链表中存放哈希值和散列桶取模运算相同的Entry。

```java
transient Entry[] table;
```

```java
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;

    Entry(int h, K k, V v, Entry<K,V> n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null && k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null && v1.equals(v2)))
                return true;
        }
        return false;
    }

    public final int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }

    public final String toString() {
        return getKey() + "=" + getValue();
    }
}
```

2.拉链法工作原理





















### JDK源码分析

------



#### HashMap

4. ##### 问题

   4.1 相对于JDK1.7的区别

   - 使用了红黑树

     JDK1.8的内部实现是数组+链表+红黑树；

     1.8之前是数组+链表实现。对于一个key，先计算其hash值再对数组大小取模决定放在哪个元素上，再通过连地址发解决hash冲突；

     如果很多key映射到了同一个元素上，那么效率退化成O(N)，因此，JDK1.8在链表超过阈值的时候会转成红黑树，效率为O（logN）

   - 解决了并发时resize时的死循环

     保留了顺序，使用的尾插法而不是头插法。

   4.2 如何解决并发时resize时的死循环

   ​	保留了顺序，使用的尾插法而不是头插法。

   4.3 什么时候扩容

   ​	size > 容量*负载因子

   4.4 怎么扩容的

   ​	参考putVla方法

   

   









### TODO的题目

------

#### 基础题目

1、Java线程的状态

2、进程和线程的区别，进程间如何通讯，线程间如何通讯

3、HashMap的数据结构是什么？如何实现的。和HashTable、ConcurrentHashMap的区别

4、Cookie和Session的区别

5、索引有什么用？如何创建索引？

6、ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。

7、equals方法实现

8、面向对象

9、线程状态，BLOCKED和WAITING有什么区别

10、JVM如何加装字节码文件

11、JVM GC，GC算法

12、什么情况会出现Full GC，什么情况会出现yong GC。

13、JVM内存模型

14、Java运行时数据区

15、事务的实现原理



#### 技术深度

1、有没有看过JDK源码，看过的类实现原理是什么

2、HTTP协议

3、TCP协议

4、一致性Hash算法

5、JVM如何加载字节码文件

6、类加载器如何卸载字节码

7、IO和NIO的区别，NIO的有点

8、Java线程池的实现原理，keepliveTime等参数的作用

9、HTTP连接池实现原理

10、数据库连接池的实现原理

11、数据库的实现原理



#### 技术框架

1、看过哪些开源框架的源码

2、为什么要用Redis，Redis有哪些优缺点

3、Neety是如何使用线程池的，为什么这么使用

4、为什么要使用Spring，Spring的优缺点有哪些

5、Spirng的IOC容器初始化流程

6、Spring的IOC容器实现原理，为什么可以通过byName和byTipe找到Bean

7、Spring AOP实现原理

8、消息中间件是如何实现的，技术难点有哪些



#### 系统架构

1、如何搭建一个高可用系统

2、哪些设计模式可以增加系统的可扩展性

3、介绍设计模式，如模板模式，命令模式，策略模式，适配器模式，桥接模式、装饰模式，观察者模式，状态模式，访问者模式。

4、抽象能力，怎么提高研发效率。

5、什么是高内聚低耦合，请举例子如何实现

6、什么情况用接口，什么情况用消息

7、如果AB两个系统互相依赖，如何解除依赖

8、如何写一篇设计文档，目录是什么

9、什么场景应该拆分系统，什么场景应该合并系统

10、系统和模块的区别，分别在什么场景下使用



#### 分布式系统

1、分布式事务，两阶段提交

2、如何实现分布式锁

3、如何实现分布式Session

4、如何保证消息的一致性

5、负载均衡

6、正向代理（客户端代理）和反向代理（服务端代理）

7、CDN实现原理

8、怎么提升系统的QPS和吞吐量



#### 实战能力

1、有没有处理过线上问题？出现内存泄漏，CPU利用率标高，应用无响应时如何处理的

2、开发中有没有遇到什么技术问题？如何解决的？

3、若有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。

4、新浪微博是如何实现把微博推给订阅者

5、Google是如何在一秒内把搜索结果返回给用户的

6、12306网站的订票系统如何实现，如何保证票不会被超卖。

7、如何实现一个秒杀系统，保证只有几位用户能买到某件商品。



#### 软能力

1、如何学习一项新技术，比如学习Java的，重点学习什么

2、有关注哪些新的技术

3、工作任务非常多非常杂时如何处理

4、项目出现延迟如何处理

5、和同事的设计思路不一样怎么处理

6、如何保证开发质量

7、职业规划是什么？短期，长期目标是什么

8、团队的规划是什么

9、能介绍下从工作到现在自己的成长在那里
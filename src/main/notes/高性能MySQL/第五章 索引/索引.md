## 索引
### 一、索引的分类
#### 1、B-Tree索引
##### 1.1优点
 * 1、 **大多数MySQL存储引擎的默认索引类型** 
 * 2、 **B-Tree索引使用B-Tree数据结构来存储数据，实际上很多存储引擎**

用的是B+Tree。   
  > * 关于B+Tree 数据结构
  > > * B Tree指的是Balance Tree，也就是平衡树。平衡树是一颗查找树，所有叶子节点位于同一层。
  > > * B+ Tree是基于B Tree和叶子节点顺序访问指针进行实现，它具有B Tree的平衡性，并且通过顺序访问指针来提高区间
    查询的性能。
  > > * 插入删除操作会破坏平衡树的平衡性，因此在插入和删除操作之后，需要对树进行分裂、合并、旋转来维护树的平衡性。
  > * 与红黑树的比较
  > > 红黑树等平衡树也可以用来实现索引，但文件系统及数据库系统普遍采用B+ Tree作为索引结构，主要由一下两个原因：
  > > * 更少的查找次数。
  > > > *平衡树的查找操作的时间复杂度等于树高，树高大致为O(h)=O(logdN)，其中d为每个节点的出度。
  > > > *红黑树的出度为2，而B+ Tree的出度一般都非常大，故红黑树的树高比B+ Tree大很多，其查找次数也就更多。
  > > * 利用磁盘预读特性
  > > > * 磁盘I/O时，会进行预读。预读无需磁盘寻道，速度快。
  > > > * 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将
    索引一个节点的大小设置为页的大小，一次I/O就能完全载入一个节点，利用预读特性，相邻节点也能被预加载。
 * 3、 **能够加快访问数据的速度。因为不需要进行全表扫描，只需从索引的根节点开始搜索即可。**
 * 4、 **适合查找范围数据，因为B-Tree对索引列是顺序存储的。**
 * 5、 **可使用B-Tree索引的查询类型：全键值、键值范围或键前缀查找（只适用根据最左前缀查找）。**
 > * 全值匹配。
 > * 匹配最左前缀。只使用索引的第一列。
 > * 匹配前缀列。可以只匹配某一列的值的开头部分。
 > * 匹配范围值。
 > * 精确匹配某一列并范围匹配另外一列。
 > * 只访问索引的查询。
 * 6、 **除了用于查找，还可用于排序和分组。**
##### 1.2 缺点
 * 1、 如果不是按照索引的最左列开始查找，则无法使用使用索引。
 * 2、 不能跳过索引中的列。
 * 3、 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。
#### 2、哈希索引
> * 哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎会对所有的索引列计算一个
哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储
在索引中，同时在哈希表中保存指向每个数据行的指针。
> * MySQL中只有Memory显示支持哈希索引，也是Memory默认的索引类型。且支持非唯一哈希索引。
* 哈希索引非常快，（能以O(1)的时间进行查找？----引自：https://github.com/LZKO/CS-Notes/blob/master/notes/MySQL.md）。
它的结构十分紧凑，因为索引只需存储对应的哈希值。
* 哈希索引的限制：
  * 1、不能用索引中的值来避免读取行，因为哈希索引中只包含哈希值和行指针，不存储字段值。
  * 2、无法用于排序，因为它不是按照索引值顺序存储的。
  * 3、不支持部分索引列匹配查找，因为哈希索引使用索引列的全部内容计算哈希值。
  * 4、只支持等值比较查询，不支持任何范围查询。
  * 5、访问哈希索引的速度非常快，除非有很多哈希冲突。
  * 6、如果哈希冲突很多，一些索引维护操作的代价也很高。冲突越多，代价越大。
## 3、空间数据索引（R-Tree)
  * MyISAM表支持空间数据索引，可以用作地理数据存储。
  * 会从所有维度来索引数据，可以有效地使用任意维度来组合查询。
  * 必须使用MySQL的GIS相关函数来维护数据。
## 4、全文索引
  * 它查找的是文本中的关键词，而不是直接比较索引中的值
  * 查找条件使用MATCH AGAINST,不是普通的WHERE条件操作。
## 5、其他索引类别
  * TukuDB使用分形树索引（fractal tree index）
  * ScaleDB使用Patricia tries。
# 二、索引的优点
 * 1、大大减少了需要扫描的数据量。
 * 2、帮助服务器进行排序和分组，避免创建临时表（B+Tree索引是有序的，可用于ORDER BY和GROUP BY操作。临时表主要是在排序和
    分组的时候创建的，因为不需要排序和分组，也就不需要创建临时表）。
 * 3、将随机I/O变为顺序I/O（B+Tree索引是有序的，会将相邻的数据都存储在一起）。
 ### 扩展
 > 1、如何评价一个索引是否适合某个查询的“三星系统”？
 >> * 1.1 索引将相关的记录放到一起则获得一星；
 >> * 1.2 如果索引中的数据顺序和查找中的排列顺序一致则获得二星；
 >> * 1.3 如果索引中的列包含了查询中需要的全部列则获得三星。
 
 > 2、 索引是最好的解决方案吗？
 >> * 2.1 索引并不总是最好的工具。总的来说，只有当索引帮助存错引擎快速查找到记录所带来的好处大于穷带来的额外工作时，
    索引才是有效的。
 >> * 2.2 对于非常小的表，大部分情况下简单的全表扫描更高效。
 >> * 2.3 对于中到大型表，索引非常有效。
 >> * 2.4 对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，需要一种技术可以直接区分出查询需要的一组数据，
    而不是一条记录一条记录的匹配。如可以使用分区技术等。
    
# 三、高性能的索引策略----索引优化
 * 1、独立的列
    > 进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
    
    > 如下面这个查询无法使用actor_id列的索引
    
    ` SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; `
    
 * 2、前缀索引和索引选择性
    > 对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，只索引开始部分的字符串，MySQL不允许索引这些列
        的完整长度。
    
    > 对于前缀长度的选取，需要根据索引的选择性来决定。
   >> 索引选择性是指：不重复的索引值（也成为基数,cardinality）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。
    
    如下面显示的结果中customer_id比的选择性比staff_id更高
   ```sql
    SELECT COUNT(DISCONNECT staff_id)/COUNT(*) AS staff_id_selectivity,
    COUNT(DISCONNECT customer_id)/COUNT(*) AS customer_id_selectivity,
    COUNT(*)
    FROM payment;
    ```
    ```html
    staff_id_selectivity:0.0001
    customer_id_selectivity:0.0373
    COUNT(*):16049
    ```
    
 * 3、多列索引
    > 在需要使用多个条件进行查询时，使用多列索引比使用多个单列索引性能更好。
    
    > 如下面的语句中，最好把actor_id和film_id设置为多列索引。 
    
    ```sql
    SELECT film_id,actor_id FROM sakila.film_actor
    WHERE actor_id = 1 AND film_id = 1; 
    ```  

 * 4、选择合适的索引列顺序
 
 > 当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的，此时，索引的作用只是优化WHERE条件的查找。
    能够最快地过滤出需要的行，对于WHERE字句中只使用了索引部分前缀列的查询来说选择性也更高。
    除了索引列的选择性之外，性能也和查询条件的具体值有关，也就是和值的分布有关。可能需要根据运行频率最高的的查询
    来调整索引列的顺序，让这种情况下的索引选择性更高。

 >  尽管关于选择性和基数的经验法则值得去研究和分析，但一定要记住别忘了WHERE字句中的排序、分组和范围条件等其他因
 素，这些可能对查询的性能造成非常大的影响。
  
  * 5、聚簇索引
  
  聚簇索引不是一种单独的索引类型，而是一种数据存储的方式。
  
  InnoDB的聚簇索引是在同一个结构中保存了B-Tree索引和数据行。
  
  一个表只能有一个聚簇索引。因为无法同时把数据行存放在两个不同的地方。
  
  由于存储引擎负责实现索引，所以不是所有的存储引擎都支持聚簇索引，此处只讨论InnoDB。
  
  聚簇索引的优点：
  
  > 1、可以把相关数据保存在一起。
  
  > 2、数据访问更快。
  
  > 3、使用覆盖索引扫描的查询可以直接使用页节点中的主键值。
  
  聚簇索引的缺点：
  
  > 1、若将数据全部放在内存中，则访问的顺序也没那么重要了，聚簇索引也就没什么优势了。
  
  > 2、插入速度眼中依赖于插入顺序。
  
  > 3、更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
  
  > 4、基于聚簇索引的表在插入新行，或主键被更新需要移动行的时候，可能会面临分裂的问题。
  
  > 5、聚簇索引可能呆滞全表扫描变慢，尤其是行比较稀疏的时候，或由于也分裂导致数据存储不连续的时候。
  
  > 6、二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的主键列包含了引用行的主键列。
  
 * 6、覆盖索引
 
    如果一个索引包含（或者说覆盖）所有需要查询字段的值，我们称之为“覆盖索引”。
    
    无须回表的好处：
    
    > 1、索引条目通常远小于数据行的大小，若只需读取索引，可以极大地减少数据访问量。
    
    > 2、对于I/O密集型的范围查询会比随机从磁盘读取每一行的数据I/O要少得多。
    
    > 3、一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使
    用系统调用（通常比较费时）。
    
    > 4、对于InnoDB的聚簇索引，InnoDB的二级索引在叶子节点中保存了行的主键值，如果二级主键能够覆盖查询，则可
    避免对主键索引的二次查询。
    
    不是所有类型的索引都能成为覆盖索引。覆盖索引必须要存储索引列的值，哈希索引、空间索引和全文索引等都不存储索引列的值，
    故MySQL只能使用B-Tree索引做覆盖索引。
    
 * 7、使用索引扫描来做排序
 
    MySQL有两种方式可以生成有序结果：通过排序操作；或按索引顺序扫描。
    
 * 8、压缩（前缀压缩）索引
 
 * 9、冗余索引和重复索引
 
    重复索引：按照相同的顺序创建的相同类型的索引。
    
    > 应该避免创建重复索引，发现后应立即移除。
    
    冗余索引：若创建了索引（A,B），再创建索引（A）就是冗余索引，因为这是前一个索引的前缀索引。
    
    大多数情况下都不需要冗余索引，应尽量扩展已有的索引而不是创建新索引。但也有时候出于性能方面的考虑需要创建冗余索引，
    因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。
    
    解决冗余索引和重复索引：删除这些索引即可。
    
    但首先要做的是这些索引。建议使用Percona工具箱中的py-upgrade工具来仔细检查计划中的索引变更。
    
 * 10、删除未的索引
 
 * 11、索引和锁
 
    索引可以让查询锁定更少的行。InnoDB只有在访问行的时候才会对其枷锁，索引能够减少InnoDB访问的行数，从而减少锁的数量。 
    
    
    

 
 
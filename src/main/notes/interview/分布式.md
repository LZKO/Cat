## 分布式

[参考](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md)

------

### 分布式锁

在单机场景下可以使用语言的内置锁来实现进程同步。若在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要分布式锁。

阻塞锁通常使用互斥量来实现：

- 互斥量为0表示有其他进程在使用，此时出于锁定状态；
- 互斥量为1表示未锁定的状态。

1和0可以用一个整形值表示，也可以用某个数据是否存在咋表示。

#### 实现方式：

##### 数据库唯一索引

获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，故可以用这个记录是否存在来判断是否处于锁定状态。

该方法存在如下几个问题：

- 锁没有失效时间，解锁失败的话其他进程无法再获得该锁；
- 只能是非阻塞锁，插入失败直接就报错了，无法重试；
- 不可重入。已经获得该锁的进程也必须重新获取锁。



##### Redis的SETNX命令

使用SETNX（set if not exist）指令插入一个键值对时，如果Key已经存在，则返回false，否则插入成功并返回true。

SETNX指令和数据库的唯一索引类似，保证了只存在一个Key的键值对，故可以用一个Key的键值对是否存在来判断是否处于锁定状态。

EXPIRE指令可以为一个键值对设置一个过期时间，从而避免了数据库的唯一索引实现方式中释放锁失败的问题。



##### Redis的RedLock算法

使用了多个Redis实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。

- 尝试从N个互相独立Redis实例获取锁；
- 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，才认为获取锁成功；
- 如果获取锁失败，就到每个实例上释放锁。



##### Zookeeper的有序节点

###### 1.Zookeeper抽象模型

Zookeeper提供了一种树形结构的命名空间，/app1/p_1节点的父节点为/app1。

（没看懂这儿，图片不显示了，后续补充，地址：https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81）

###### 2.节点类型

- 永久节点：不会因为会话结束或超时而消失；
- 临时节点：若会话结束或超时就会消失；
- 有序节点：会在节点名的后面加一个数字后缀，且是有序的，如 生成的有序节点为/lock/node-0000000000，它的下一个有序节点则为/lock/node-0000000001，以此类推。

###### 3.监听器

为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。

###### 4.分布式锁的实现

- 创建一个锁目录/lock；
- 当一个客户端需要获取锁时，在/lock下创建临时的且有序的子节点；
- 客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤，直至获得锁；
- 执行业务代码，完成后，删除对应的子节点。

###### 5.会话超时

若一个已经获得锁的会话超时了，因为创建的是临时节点，故该会话对应的临时节点会被删除，其他会话就可获得锁了。故这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。

###### 6.羊群效应

一个节点未获得锁，只需要监听自己的前一个子节点，因为如果监听所有的子节点，那么任意一个子节点状态改变，其他所有子节点都会收到通知（羊群效应，一只羊动起来，其他羊也会一哄而上），而我们只希望它的后一个子节点收到通知。



### 分布式事务

指事务的操作位于不同的节点上，需要保证事务的ACID特性。

如在下单的场景下，库存和订单如果不在同一个节点上，就会涉及分布式事务。

分布式锁和分布式事务的区别：

- 锁问题的关键在于进程操作的互斥关系，如多个进程同时修改账户的余额，若没有互斥关系，则会导致该账户的余额不正确。
- 而事务问题的关键在于事务涉及的一系列操作需要满足ACID特性，如要满足原子性操作，则需要这些操作要么都执行，要么都不执行。



#### 实现方式：

##### 2PC

两阶段提交（Two-phase Commit , 2PC），通过引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。

1.运行过程

1.1 准备阶段

协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。

1.2 提交阶段

若事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。。

需要注意，在准备阶段，参与者执行了事务，但还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。

2.存在的问题

2.1 同步阻塞

所有事务参与者在等待其他参与者响应的时候都处于同步阻塞等待状态，无法进行其他操作。

2.2 单点问题

协调者在2PC中起到非常大的作用，（协调者）发生故障会在成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其他操作。

2.3 数据不一致

在提交阶段，若协调者只发送了部分Commit消息，此时网络发生异常，那么只有部分参与者接收到Commit消息，即 只有部分参与者提交了事务，使得系统数据不一致。

2.4 太过保守

任意一个节点的失败就会导致整个事务失败，没有完善的容错机制。



##### 本地消息表

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证对这两个表的操作满足事务特性，切使用了消息队列来保证最终一致性。

1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。



### CAP

分布式系统不可能同时满足一致性（C : Consistency）、可用性（A : Availability）和分区容忍性（P : Partition），最多只能同时满足其中两项。

（分区容忍性（P : Partition） 是否可以翻译成 分区容错性？）

#### 一致性

一致性指多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。

对系统的一个数据更新之后，若所有用户都能够读取到最新的值，该系统就被人为具有强一致性。

#### 可用性

可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用 系统可用时间占总时间的比值来衡量，4个9的可用性表示系统 99.99%的时间是可用的。

在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

#### 分区容忍性

网络分区指分布式系统中的节点被划分为多个区域，每个区域内部都可以通信，但是区域之间无法通信。

在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境发生了故障。

#### 权衡

在分布式系统中，分区容忍性是必不可少的，因为需要总是假设网络是不可靠的。因此，CAP理论实际上是要在可用性和一致性之间做权衡。

可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，

- 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
- 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。



### BASE

BASE是基本可用（Basically Available）、软状态（Soft State）和最终一致性三个短语的缩写。

BASE理论是对CAP中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

#### 基本可用

指分布式系统出现故障的时候保证核心可用，允许损失部分可用性。

如 电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

#### 软状态

指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本直接进行同步的过程存在延时。

#### 最终一致性

最终一致性强调的是 系统中所有的数据副本，经过一段时间的同步后，最终达到一致的状态。

ACID要求强一致性，通常运用在传统的数据库系统上。而BASE要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，故ACID和BASE往往会结合使用。



### Paxos

半小时学会什么是分布式一致性算法——Paxos（https://blog.csdn.net/westbrookliu/article/details/99713365）

用于达成共识性的问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。

主要有三类节点：

- 提议者（Proposer）：提议一个值；
- 接受者（Acceptor）：对每个提议进行投票；
- 告知者（Learner）：被告知投票的结果，不参与投票的过程。

#### 执行过程

规定一个提议包含两个字段：[n,v]，其中n为序号（具有唯一性），v为提议值。

##### 1.Prepare阶段

...下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。

[![img](https://camo.githubusercontent.com/a7b00ee89320786b6cc0c20906589991a49fc8bd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31613939373765342d326635632d343961362d616563392d6633303237633966343661372e706e67)](https://camo.githubusercontent.com/a7b00ee89320786b6cc0c20906589991a49fc8bd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31613939373765342d326635632d343961362d616563392d6633303237633966343661372e706e67)

当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。

如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。

[![img](https://camo.githubusercontent.com/a700e1e530a3130faad213298996a731b9785793/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66623434333037662d386539382d346666372d613931382d3331646163666135363462342e6a7067)](https://camo.githubusercontent.com/a700e1e530a3130faad213298996a731b9785793/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66623434333037662d386539382d346666372d613931382d3331646163666135363462342e6a7067)

如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 > n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。

如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n > 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 <= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。

[![img](https://camo.githubusercontent.com/c6a736f8d4f5dc7bce6894ca1486ae0bb13be555/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32626363353861642d626637662d343835632d383962352d6537636166633231316365322e6a7067)](https://camo.githubusercontent.com/c6a736f8d4f5dc7bce6894ca1486ae0bb13be555/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32626363353861642d626637662d343835632d383962352d6537636166633231316365322e6a7067)

##### 2.Accept阶段

...当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。

Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。

Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。

[![img](https://camo.githubusercontent.com/7f3bd0cb185d557ceb39524d27481a5ef5b19210/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39623833386165652d303939362d343461352d396230662d3364316533653266353130302e706e67)](https://camo.githubusercontent.com/7f3bd0cb185d557ceb39524d27481a5ef5b19210/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39623833386165652d303939362d343461352d396230662d3364316533653266353130302e706e67)

##### 3.Learn阶段

Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。

[![img](https://camo.githubusercontent.com/9f55215762db7fd8dabf8001891f1fcb62d3260b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62663636373539342d626234622d343633342d626639622d3035393661343534313562612e6a7067)](https://camo.githubusercontent.com/9f55215762db7fd8dabf8001891f1fcb62d3260b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62663636373539342d626234622d343633342d626639622d3035393661343534313562612e6a7067)

#### 约束条件

##### 1.正确性

...指只有一个提议值会生效。

因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。

##### 2.可终止向

指最后总会有一个提议生效。

Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。

### Raft

Raft也是分布式一致性协议，主要用来竞选主节点。

- [Raft: Understandable Distributed Consensus](

#### 单个Candidate的竞选

...有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。

- 下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。

[![img](https://camo.githubusercontent.com/8cb2281148bdfd4133333aafa47a0858d94df24d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383031353839382e676966)](https://camo.githubusercontent.com/8cb2281148bdfd4133333aafa47a0858d94df24d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383031353839382e676966)

- 此时 Node A 发送投票请求给其它所有节点。

[![img](https://camo.githubusercontent.com/d299fb602e2bc7f5ab8d0605584960699645101a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383434353533382e676966)](https://camo.githubusercontent.com/d299fb602e2bc7f5ab8d0605584960699645101a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383434353533382e676966)

- 其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。

[![img](https://camo.githubusercontent.com/bb5d42b0aedb0d6982185261eff52ec297cd27b1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383438333033392e676966)](https://camo.githubusercontent.com/bb5d42b0aedb0d6982185261eff52ec297cd27b1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383438333033392e676966)

- 之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。

[![img](https://camo.githubusercontent.com/0a00178fa3a8a62efd8f0825e2aa564c18cf2b36/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383634303733382e676966)](https://camo.githubusercontent.com/0a00178fa3a8a62efd8f0825e2aa564c18cf2b36/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383634303733382e676966)

#### 多个Candidate竞选

...

- 如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。

[![img](https://camo.githubusercontent.com/91e6a4825171acf88fc9321cf3f7a6388ea7c30c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393230333334372e676966)](https://camo.githubusercontent.com/91e6a4825171acf88fc9321cf3f7a6388ea7c30c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393230333334372e676966)

- 由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。

[![img](https://camo.githubusercontent.com/1fcaa22d6b3c959d9aca44ad37ba27fd2dba4bdb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393336383731342e676966)](https://camo.githubusercontent.com/1fcaa22d6b3c959d9aca44ad37ba27fd2dba4bdb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393336383731342e676966)

#### 数据同步

- 来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。

[![img](https://camo.githubusercontent.com/8e8165aefc5d37a5eb47fcff6157a9c2ea29f03c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37313535303431343130373537362e676966)](https://camo.githubusercontent.com/8e8165aefc5d37a5eb47fcff6157a9c2ea29f03c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37313535303431343130373537362e676966)

- Leader 会把修改复制到所有 Follower。

[![img](https://camo.githubusercontent.com/10f7413dd3a1e0df65d3c7ed5111d49a62efc4df/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313535303431343133313333312e676966)](https://camo.githubusercontent.com/10f7413dd3a1e0df65d3c7ed5111d49a62efc4df/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313535303431343133313333312e676966)

- Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。

[![img](https://camo.githubusercontent.com/25ff2e932d41feb8e105c9423a6c247a7c440818/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3130313535303431343135313938332e676966)](https://camo.githubusercontent.com/25ff2e932d41feb8e105c9423a6c247a7c440818/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3130313535303431343135313938332e676966)

- 此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。

[![img](https://camo.githubusercontent.com/82e7cdc1f7673a2136de85c3ca625591cf1f09ac/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313535303431343138323633382e676966)](https://camo.githubusercontent.com/82e7cdc1f7673a2136de85c3ca625591cf1f09ac/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313535303431343138323633382e676966)

### 参考

- 倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.
- [Distributed locks with Redis](https://redis.io/topics/distlock)
- [浅谈分布式锁](http://www.linkedkeeper.com/detail/blog.action?bid=1023)
- [基于 Zookeeper 的分布式锁](http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html)
- [聊聊分布式事务，再说说解决方案](https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html)
- [分布式系统的事务处理](https://coolshell.cn/articles/10910.html)
- [深入理解分布式事务](https://juejin.im/entry/577c6f220a2b5800573492be)
- [What is CAP theorem in distributed database system?](http://www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/)
- [NEAT ALGORITHMS - PAXOS](http://harry.me/blog/2014/12/27/neat-algorithms-paxos/)
- [Paxos By Example](https://angus.nyc/2012/paxos-by-example/)






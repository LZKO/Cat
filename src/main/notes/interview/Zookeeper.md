# Zookeeper

[参考链接](<https://www.hadyang.xyz/interview/docs/architecture/distributed/zk/>)

------

ZK 不是解决分布式问题的银弹

## 一、分布式应用

分布式应用可以在给定时间（同时）在网络中的多个系统上运行，通过协调它们以快速有效的方式完成特定任务。通常来说，**对于复杂而耗时的任务，非分布式应用（运行在单个系统中）需要几个小时才能完成，而分布式应用通过使用所有系统涉及的计算能力可以在几分钟内完成**。

通过将分布式应用配置为在更多系统上运行，可以进一步减少完成任务的时间。分布式应用正在运行的一组系统称为 **集群**，而在集群中运行的每台机器被称为 **节点**。

### 1、分布式应用的优点

- 可靠性：单个或几个系统的故障不会使整个系统出现故障。
- 可扩展性：可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间。
- 透明性：隐藏系统的复杂性，并将其显示为单个实体/应用程序。

### 2、分布式应用的挑战

- 竞争条件：两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。
- 死锁：两个或多个操作等待彼此无限期完成。
- 不一致：数据的部分失败。

## 二、ZooKeeper基础

Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。

ZooKeeper 的好处：

- 简单的分布式协调过程
- 同步：服务器进程之间的相互排斥和协作。
- 有序性
- 序列化：根据特定规则对数据进行编码(Jute)。
- 可靠性
- 原子性：数据转移完全成功或完全失败，但没有事务是部分的。

### 1、架构

一个 ZooKeeper 集群通常由一组机器组成，一般 3 台以上就可以组成一个可用的 ZooKeeper 集群了。组成 `ZooKeeper` 集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都会互相保持通信。 ZooKeeper 本身就是一个 **复制和分布式** 应用程序，其目的作为服务运行，类似于我们运行 DNS 或任何其他集中式服务的方式。

> ZK 集群 **半数以上存活** 即可用

ZooKeeper 的客户端程序会选择和集群中的任意一台服务器创建一个 TCP 连接，而且一旦客户端和服务器断开连接，客户端就会自动连接到集群中的其他服务器。

![image](https://www.hadyang.xyz/interview/docs/architecture/distributed/zk/images/cde28984c2c32a5068b2b31d5ba2040f.png)

| 部分              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| Client（客户端）  | 客户端是我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。 |
| Server（服务器）  | 服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。 |
| ZooKeeper Service | ZooKeeper服务器组。形成 Service 所需的最小节点数为3。        |
| Leader            | 服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。 |
| Follower          | 用于接受客户端请求并向客户端返回结果，在选主过程中参与投票   |
| Observer          | 接受客户端连接，将写请求转发给leader，但 observer **不参与** 投票过程，只同步 leader 的状态， observer 的目的是为了扩展系统，提高读取速度 |

### 2、数据模型

![image](https://www.hadyang.xyz/interview/docs/architecture/distributed/zk/images/944a3ed0ab807a87b5c562c58a31ea2b.png)

到znode是一个标准的文件系统，层次结构很像一棵树。 需要注意的一些要点如下：

- 根节点有一个名为 `/zoo` 的子节点，它又有三个 `znode` 。
- ZooKeeper 树中的每个 `znode` 都由一个路径标识，路径元素由`/`分隔。
- 这些节点被称为数据寄存器，因为它们可以存储数据。 因此，一个 znode 可以有子节点以及与之相关的数据。 这与文件系统可以把文件作为路径很类似。

znode 中的数据通常以字节格式存储，**每个 znode 中的最大数据大小不超过1 MB**。 ZooKeeper 是为协调而设计的，几乎所有形式的协调数据都比较小， 因此，对数据大小的限制是强制的。

与文件系统中的文件一样， `znode` 维护一个 `stat` 结构，其中包含数据更改的 **版本号** 以及随更改相关的时间戳而更改的 **访问控制列表（ACL）**。 只要 znode 的数据发生变化，版本号就会增加。 ZooKeeper 使用版本号以及相关的时间戳来验证它的核心内缓存。 znode 版本号还允许客户端通过 ZooKeeper API 更新或删除特定的 znode。 如果指定的版本号与 znode 的当前版本不匹配，则操作失败。 但是，执行 znode 更新或删除操作时，可以通过指定 0 作为版本号来覆盖。

### 3、Znode

- **persistent**：即使在创建该特定znode的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode都是持久的。
- **ephemeral**：客户端活跃时，临时节点就是有效的。当客户端与 ZooKeeper 集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在 leader 选举中起着重要作用。
- **sequential**：顺序节点可以是持久的或临时的。当一个新的 znode 被创建为一个顺序节点时，ZooKeeper 通过将 **10位** 的序列号附加到原始名称来设置 znode 的路径。例如，如果将具有路径 `/myapp` 的znode创建为顺序节点，则ZooKeeper会将路径更改为 `/myapp0000000001` ，并将下一个序列号设置为`0000000002`。如果两个顺序节点是同时创建的，那么 ZooKeeper **不会对每个znode使用相同的数字**。顺序节点在锁定和同步中起重要作用。

### 4、Sessions

会话对于 ZooKeeper 的操作非常重要。会话中的请求按 FIFO 顺序执行。一旦客户端连接到服务器，将建立会话并向客户端分配 **会话ID** 。

客户端 **以特定的时间间隔发送心跳** 以保持会话有效。如果 ZooKeeper 集合在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。

会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。

### 5、Watcher

`ZooKeeper` 的设计是一种可伸缩的、健壮的集中式服务。在客户端访问此类服务时，常见的设计模式是通过轮询或拉式（pull）模型。当在大型和复杂的分布式系统中实现时，拉模型常常会受到可伸缩性问题的影响。为了解决这个问题，ZooKeeper设计了一种机制，**客户端可以从 ZooKeeper 服务中获取通知。客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据**。

客户可以使用 `ZooKeeper` 服务注册与 `znode` 相关的任何更改。 这种注册被称为在 `ZooKeeper` 术语中的 `znode` 上设置 `watch`。 监视允许客户以任何方式更改 `znode` 时收到通知。 **Watcher 是一次性操作**，这意味着它只触发一个通知。 要继续接收通知，客户必须在收到每个事件通知后重新注册一个监视。

监视触发：

- 对 znode 数据的任何更改，例如使用 `setData` 操作将新数据写入 znode 的数据字段时。
- 对 znode 的子节点的任何更改。 例如，一个 znode 的子节点被删除。
- 正在创建或删除的 znode ，如果将新的 znode 添加到路径中或现有的 znode 被删除，则可能发生这种情况。

同样，ZooKeeper 针对监视和通知声明以下保证：

- ZooKeeper 确保监视始终以先进先出（FIFO）方式排序，并且通知总是按顺序发送
- 在对同一个 znode 进行任何其他更改之前，监视会将通知发送给客户端
- 监视事件的顺序是按照 ZooKeeper 服务的更新顺序排列的

## 三、Zookeeper 工作流程

### 1、ZooKeeper Service 节点数量的影响

## 四、ZAB 协议

### 1、消息广播

### 2、崩溃恢复

## 五、应用场景

### 1、发布订阅

### 2、命名服务

### 3、协调分布式事务

### 4、分布式锁

## 六、ZooKeeper 的缺陷

### 1、zookeeper 不是为高可用性设计的

### 2、zookeeper 的选举过程速度很慢

### 3、zookeeper 的性能是有限的

### 4、zookeeper 无法进行有效的权限控制

### 5、即使有了 zookeeper 也很难避免业务系统的数据不一致

### 6、Zookeeper 并不保证读取的是最新数据

### 7、我们能做什么

## 七、FAQ

### 1、客户端对 ServerList 的轮询机制是什么

### 2、客户端如何正确处理 CONNECTIONLOSS (连接断开) 和 SESSIONEXPIRED (Session 过期)两类连接异常

### 3、一个客户端修改了某个节点的数据，其它客户端能够马上获取到这个最新数据吗

### 4、ZK为什么不提供一个永久性的Watcher注册机制

### 5、使用watch需要注意的几点

### 6、我能否收到每次节点变化的通知

### 7、能为临时节点创建子节点吗

### 8、是否可以拒绝单个IP对ZK的访问,操作

### 9、在[`getChildren(String path, boolean watch)`]注册对节点子节点的变化，那么子节点的子节点变化能通知吗

### 10、创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？

### 11、ZooKeeper集群中个服务器之间是怎样通信的？

## 八、参考文档

- [ZooKeeper FAQ](http://jm.taobao.org/2013/10/07/zookeeper-faq/)
- [Apache ZooKeeper数据模型](https://www.cnblogs.com/IcanFixIt/p/7818592.html)
- [Zookeeper并不保证读取的是最新数据](http://www.crazyant.net/2120.html)
- [详解分布式协调服务 ZooKeeper](https://draveness.me/zookeeper-chubby)
- [ZooKeeper 架构](https://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html)
- [阿里巴巴为什么不用ZooKeeper 做服务发现？](http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/)
- [ZooKeeper 技术内幕：Leader 选举](http://ningg.top/zookeeper-lesson-2-leader-election/)


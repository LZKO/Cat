# 面试问题整理

### Redis

------

#### 应用场景

1.缓存

2.共享Session

3.消息队列系统

4.分布式锁



#### 单线程的Redis为什么快

1.纯内存操作

2.单线程操作，避免了频繁的上下文切换

3.合理高效的数据结构

4.采用了非阻塞的I/O多路复用机制



#### Redis的数据结构及使用场景

1.String字符串：字符串类型是Redis最基础的数据结构，首先键都是字符串类型，且其他几种数据结构都是在字符串类型基础上构建的，我们常使用的set key value命令就是字符串（语句没读懂？）。常用在缓存、技术、共享Session、限速等。

2.Hash哈希：在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可用来存放用户信息，如实现购物车（如何实现？）。

3.List列表（双向链表）：列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。

4.Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，且集合中的元素是无序的，不能通过索引下标获取元素。利用Set的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

5.Sorted Set有序集合（跳表实现）：Sorted Set多了一个权重参数Score，集合中的元素能够按Score进行排列。可以做排行榜应用，取TOP N操作。



#### Redis的数据过期策略

Redis中数据过期策略采用定期删除+惰性删除策略

- 定期删除策略：Redis启用一个定时器定时监视所有的key，判断key是否过期，过期的话就删除。这种策略可以保证过期的key最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗CPU资源，并且当key已过期，但是定时器还处于未唤起状态，这段时间内key仍然可以用。

惰性删除策略：在获取key是时，先判断key是否过期，如果过期则删除。缺点：如果这个key一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。
- 这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不再是每次扫描全部的key了，而是随机抽取一部分key进行检查，这样就降低了对CPU资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求（语句不太通顺？）。但有时候比较巧，既没有被定时器抽取到，又没有被使用，只写数据如何从内存中消失？此时我们有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。淘汰策略分为：

  ​	当内存不足以容纳新写入数据时，

  - 新写入操作会报错（Redis默认策略）
  - 在键空间中，移除最近最少使用的Key。（LRU推荐使用）
  - 在键空间中，随机移除某个Key。
  - 在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis即当缓存，又做持久化存储时才用。
  - 在设置了过期时间的键空间中，随机移除某个Key。
  - 在设置了过期时间的键空间中，有更早过期时间的Key优先移除



#### Redis的LRU具体实现：

传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致select *的时候产生大量非热点数据占领头部数据（没看懂），故需要改进。Redis每次按key获取一个值的时候，都会更新value的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的。在3.0的时候，改进了算法，首先第一次随机选取的key都会放入一个pool中（poll的大小为16），pool中的key是按lru的大小顺序排列的。接下来每次随机选取的key的lru的值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。



#### 如何解决Redis缓存雪崩的问题

1.使用Redis高可用架构：使用Redis集群来保证Redis服务不会挂掉。

2.缓存时间不一致，给缓存的失效时间加上一个随机值，避免集体失效。

3.限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务。



#### 如何解决Redis缓存穿透问题

（TODO 什么是缓存穿透？）

1.在接口做校验

2.存null值（缓存击穿加锁）

3.布隆过滤器拦截：将所有可能的查询key先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，若不存在，则直接返回。布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素存在，可能会被误判，布隆过滤器说某个元素不存在，则一定不存在。



#### Redis的持久化机制

Redis为了保证效率，数据缓存在了内存中，但会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。

Redis的持久化策略有两种：

1. RDB（快照持久化）：加个某个时间点的所有数据都写入到磁盘里面；可以将快照复制到其他服务器从而创建具有相同数据的服务器副本；如果系统发生故障，将会丢失最后一次创建快照之后的数据；若数据量很大，保存快照的时间会很长。当Redis需要做持久化时，Redis会fock一个子进程，子进程将数据写到磁盘上的一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。

2. AOF（只追加文件）：将写命令添加到AOF文件（Append Only File）的末尾。使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定何时同步到磁盘。有以下同步选项：

   | 选项     | 同步频率               |
   | -------- | ---------------------- |
   | always   | 每个写命令都同步       |
   | everysec | 每秒同步一次           |
   | no       | 让操作系统决定何时同步 |

   - always选项会眼中降低服务器的性能；

   - everyse选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，且Redis每秒执行一次同步对服务器性能几乎没有任何影响；
   - no选项并不能给服务器性能带来多大提升，且会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF文件会越来越大。Redis提供了一只能怪将AOF重写的特性，能够去除AOF文件中冗余写命令。

这两种持久化方法既可以同时使用，又可以单独使用，在某些情况下甚至可以都不使用，具体选择哪种持久化方法需要根据用户的数据及应用来决定。



#### Redis和memcached的区别

相同点：两者都是菲关系型内存键值数据库；

不同点：

​	1.数据类型：memcached仅支持字符串类型，而Redis支持五种不同的数据类型，可以更灵活的解决问题。

​	2.数据持久化：Redis支持两种持久化策略，RDS快照和AOF日志，而Memcached不支持持久化。

​	3.分布式：Memcached不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点；Redis Cluster实现了分布式的支持。

​	4.内存管理机制：在Redis中，并不是所有数据都一直存储在内存中的，可以将一些很久没用的value交换到磁盘，而Memcached的数据则会一直在内存中；Memcached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但这种方式使得内存的利用率不高，如块的大小为128bytes，只存储100bytes的数据，剩下的28bytes就浪费掉了。



#### Redis并发竞争key的解决方案

（TODO看不懂）

1.分布式锁+时间戳

2.利用消息队列


















# 面试问题整理

### Redis

------

#### 应用场景

1.缓存

2.共享Session

3.消息队列系统

4.分布式锁



#### 单线程的Redis为什么快

1.纯内存操作

2.单线程操作，避免了频繁的上下文切换

3.合理高效的数据结构

4.采用了非阻塞的I/O多路复用机制



#### Redis的数据结构及使用场景

1.String字符串：字符串类型是Redis最基础的数据结构，首先键都是字符串类型，且其他几种数据结构都是在字符串类型基础上构建的，我们常使用的set key value命令就是字符串（语句没读懂？）。常用在缓存、技术、共享Session、限速等。

2.Hash哈希：在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可用来存放用户信息，如实现购物车（如何实现？）。

3.List列表（双向链表）：列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。

4.Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，且集合中的元素是无序的，不能通过索引下标获取元素。利用Set的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

5.Sorted Set有序集合（跳表实现）：Sorted Set多了一个权重参数Score，集合中的元素能够按Score进行排列。可以做排行榜应用，取TOP N操作。

| 数据类型 | 可以存储的值           | 操作                                                         |
| -------- | ---------------------- | ------------------------------------------------------------ |
| STRING   | 字符串、整数或浮点数   | 对整个字符串或字符串的其中一部分执行操作；对整数和浮点数执行自增或自减操作 |
| LIST     | 列表                   | 从两端压入或者弹出元素；对单个或者多个元素进行修剪，只保留一个范围内的元素 |
| SET      | 无序集合               | 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集从集合里面随机获取元素 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对；获取所有键值对；检查某个键是否存在 |
| ZSET     | 有序集合               | 添加、获取、删除元素；根据分支范围或者成员来获取元素；计算一个键的排名 |
|          | ··                     |                                                              |

#### Redis的数据过期策略

Redis中数据过期策略采用定期删除+惰性删除策略

- 定期删除策略：Redis启用一个定时器定时监视所有的key，判断key是否过期，过期的话就删除。这种策略可以保证过期的key最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗CPU资源，并且当key已过期，但是定时器还处于未唤起状态，这段时间内key仍然可以用。

- 惰性删除策略：在获取key是时，先判断key是否过期，如果过期则删除。缺点：如果这个key一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。

- 这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不再是每次扫描全部的key了，而是随机抽取一部分key进行检查，这样就降低了对CPU资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求（语句不太通顺？）。但有时候比较巧，既没有被定时器抽取到，又没有被使用，只写数据如何从内存中消失？此时我们有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。淘汰策略分为：

  ​	当内存不足以容纳新写入数据时，

  - 新写入操作会报错（Redis默认策略）
  - 在键空间中，移除最近最少使用的Key。（LRU推荐使用）
  - 在键空间中，随机移除某个Key。
  - 在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis即当缓存，又做持久化存储时才用。
  - 在设置了过期时间的键空间中，随机移除某个Key。
  - 在设置了过期时间的键空间中，有更早过期时间的Key优先移除



#### Redis的LRU具体实现：

传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致select *的时候产生大量非热点数据占领头部数据（没看懂），故需要改进。Redis每次按key获取一个值的时候，都会更新value的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的。在3.0的时候，改进了算法，首先第一次随机选取的key都会放入一个pool中（poll的大小为16），pool中的key是按lru的大小顺序排列的。接下来每次随机选取的key的lru的值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。



#### 如何解决Redis缓存雪崩的问题

1.使用Redis高可用架构：使用Redis集群来保证Redis服务不会挂掉。

2.缓存时间不一致，给缓存的失效时间加上一个随机值，避免集体失效。

3.限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务。



#### 如何解决Redis缓存穿透问题

（TODO 什么是缓存穿透？）

1.在接口做校验

2.存null值（缓存击穿加锁）

3.布隆过滤器拦截：将所有可能的查询key先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，若不存在，则直接返回。布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素存在，可能会被误判，布隆过滤器说某个元素不存在，则一定不存在。



#### Redis的持久化机制

Redis为了保证效率，数据缓存在了内存中，但会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。

Redis的持久化策略有两种：

1. RDB（快照持久化）：加个某个时间点的所有数据都写入到磁盘里面；可以将快照复制到其他服务器从而创建具有相同数据的服务器副本；如果系统发生故障，将会丢失最后一次创建快照之后的数据；若数据量很大，保存快照的时间会很长。当Redis需要做持久化时，Redis会fock一个子进程，子进程将数据写到磁盘上的一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。

2. AOF（只追加文件）：将写命令添加到AOF文件（Append Only File）的末尾。使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定何时同步到磁盘。有以下同步选项：

   | 选项     | 同步频率               |
   | -------- | ---------------------- |
   | always   | 每个写命令都同步       |
   | everysec | 每秒同步一次           |
   | no       | 让操作系统决定何时同步 |

   - always选项会眼中降低服务器的性能；
   - everyse选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，且Redis每秒执行一次同步对服务器性能几乎没有任何影响；
   - no选项并不能给服务器性能带来多大提升，且会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF文件会越来越大。Redis提供了一只能怪将AOF重写的特性，能够去除AOF文件中冗余写命令。

这两种持久化方法既可以同时使用，又可以单独使用，在某些情况下甚至可以都不使用，具体选择哪种持久化方法需要根据用户的数据及应用来决定。



#### Redis和memcached的区别

相同点：两者都是菲关系型内存键值数据库；

不同点：

​	1.数据类型：memcached仅支持字符串类型，而Redis支持五种不同的数据类型，可以更灵活的解决问题。

​	2.数据持久化：Redis支持两种持久化策略，RDS快照和AOF日志，而Memcached不支持持久化。

​	3.分布式：Memcached不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点；Redis Cluster实现了分布式的支持。

​	4.内存管理机制：在Redis中，并不是所有数据都一直存储在内存中的，可以将一些很久没用的value交换到磁盘，而Memcached的数据则会一直在内存中；Memcached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但这种方式使得内存的利用率不高，如块的大小为128bytes，只存储100bytes的数据，剩下的28bytes就浪费掉了。



#### Redis并发竞争key的解决方案

（TODO看不懂）

1.分布式锁+时间戳

2.利用消息队列



#### Redis与MySQL双写一致性方案

先更新数据库，再删除缓存。数据库的读操作，要远快于写操作，所以脏数据很难出现。可以对异步延时删除策略，保证读请求完成以后，再进行删除操作。（TODO没看懂）



#### Redis的管道pipeline

对于单线程阻塞式的Redis，pipeline可以满足批量的操作，把多个命令连续的发送给Redis Server，然后一一解析响应结果。Pipelining可以提高批量处理性能，提升原因主要是TCP连接中减少了“交互往返”的时间。pipeline底层是通过把所有的操作封装成流，redis有定义自己的出入输出流（TODO不通顺？）。在sync()方法执行操作，每次请求放在队列里面，解析响应包。



#### Redis的底层数据结构

（TODO不太理解，同时需要完善）

1.字典：

dictht是一个散列表结构，使用拉链法解决哈希冲突。

```
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```

```
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

Redis的字典dict中包含两个哈希表dictht，这是为了方便进行rehash操作。在扩容时，将其中一个dictht上的键值对rehash到另一个dictht上面，完成之后释放空间并交换两个dictht的角色。

```
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;
```

rehash操作不熟一次性完成的，而是采用渐进放手，这是为了避免一次性执行过多的rehash操作给服务器带来过大的负担。

渐进式rehash通过记录dict的rehashidx完成，他从0开始，然后每执行一次rehash都会递增。如在一次rehash中，要把dict[0] rehash到dict[1]。这一次会把dict[0]上的table[rehashidx]的键值对rehash到dct[1]上，dict[0]的table[rehashidx]指向null，并领rehashidx++。

在rehash期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式rehash。

采用渐进式rehas会导致字典中的数据分散在两个dictht上，因此对字典的查找操作也需要到对应的dictht去执行。

```
/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d)) return 0;

    while (n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d->ht[0].size > (unsigned long) d->rehashidx);
        while (d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d->ht[0].table[d->rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while (de) {
            uint64_t h;

            nextde = de->next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;
            d->ht[0].used--;
            d->ht[1].used++;
            de = nextde;
        }
        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    /* Check if we already rehashed the whole table... */
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}
```

2、跳跃表

是有序集合的地城实现之一。

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

（TODO缺少图片）

在查找时，从上层指针开始查找，找到对应的区间后再到下一层去查找。如图所示（TODO 图挂掉了）

与红黑树等平衡树相比，跳跃表具有以下优点：

- 插入速度非常快，因为不需要进行旋转灯操作来维护平衡性；
- 易实现；
- 支持无锁操作。



#### 使用场景

##### 1、计数器

可以对String进行自增自减操作，实现计数器功能。

Redis这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

##### 2、缓存

将热点数据放在内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

##### 3、查找表

如DNS记录就很适合使用Redis进行存错。

查找表和缓存类似，也是利用Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

##### 4、消息队列

List是一个双向链表，可以通过lpush和rpop写入和读取消息。

不过最好使用RocketMQ等消息中间件。

##### 5、会话缓存

可以使用Redis统一存储多态应用服务器的会话信息。

当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以氢气任意一个应用服务器，从而更容易实现高可用性及可伸缩性。

##### 6、分布式锁实现

在分布式场景下，无法使用单机环境下的锁来对多个节点的进程进行同步。

可以使用Redis自带的SETNX命令来实现分布式锁，除此之外，还可以使用官方提供的RedLock分布式锁实现。

##### 7、其他

Set可以实现交集、并集等操作，从而实现共同好友等功能。

ZSet可以实现有序性操作，从而实现排行榜等功能。



#### 事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis最简单的事务实现方式是使用MULTI和EXEC命令将事务操作包围起来。























